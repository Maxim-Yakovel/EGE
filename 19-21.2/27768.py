"""
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч один камень,
увеличить количество камней в первой куче в два раза или увеличить количество камней во второй куче в три раза.

Чтобы делать ходы, у каждого игрока есть неограниченное количество камней.

Игра завершается в тот момент, когда суммарное количество камней в кучах становится не менее 84.
Победителем считается игрок, сделавший последний ход, то есть первым получивший позицию,
в которой в кучах будет 84 или больше камней.

В начальный момент в первой куче было 16 камней, во второй куче — S камней, 1 ≤ S ≤ 67.

Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
Описать стратегию игрока — значит, описать, какой ход он должен сделать в любой ситуации,
которая ему может встретиться при различной игре противника. В описание выигрышной стратегии не следует включать
ходы играющего по ней игрока, которые не являются для него безусловно выигрышными,
т.е не гарантирующие выигрыш независимо от игры противника.

19: Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
    Укажите минимальное значение S, когда такая ситуация возможна.
20: Найдите два таких значения S, при которых у Пети есть выигрышная стратегия,
    причём одновременно выполняются два условия:
        — Петя не может выиграть за один ход;
        — Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
    Найденные значения запишите в ответе в порядке возрастания без разделительных знаков.
21: Найдите минимальное значение S, при котором одновременно выполняются два условия:
        — у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
        — у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
"""


# to
# Петя: 1 3 5
# Ваня: 2 4 6
def game(heap1, heap2, moves, to):
    if heap1 + heap2 >= 84:
        return moves % 2 == to % 2
    if moves == to:
        return 0

    h = [game(heap1 + 1, heap2, moves + 1, to),
         game(heap1 * 2, heap2, moves + 1, to),
         game(heap1, heap2 + 1, moves + 1, to),
         game(heap1, heap2 * 3, moves + 1, to)]
    # any(<массив>) - функция, которая возвращает true, если хотя бы одно значение в массиве истинно
    # Обычное условие, не накладывающее безусловный выигрыш.
    # return any(h)
    # Условие, которое не допускает ни одной возможности победы противника ("гарантированно", "независимо от того", и пр.)
    # all(<массив>) - функция, которая возвращает true, если все значения в массиве истины
    return any(h) if (moves + 1) % 2 == to % 2 else all(h)


# print(f'19: {min(s for s in range(1, 68) if not game(16, s, 0, 1) and game(16, s, 0, 2))}')
print(f'20: {[s for s in range(1, 68) if not game(16, s, 0, 1) and game(16, s, 0, 3)]}')
print(f'21: {[s for s in range(1, 68) if not game(16, s, 0, 2) and game(16, s, 0, 4)]}')